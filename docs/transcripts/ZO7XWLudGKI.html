<section>
<p><span data-start="11.6" data-end="16.53">Hi everyone. My name is Mathias and I’m here to tell you what’s new in Puppeteer!</span> <span data-start="16.53" data-end="20.58">But before we can do that, we should probably talk about what Puppeteer is in</span> <span data-start="20.58" data-end="25.77">the first place. Puppeteer is a browser automation library for Node.js. It lets you</span> <span data-start="25.77" data-end="30.03">control a browser using a simple and modern JavaScript API. After installing</span> <span data-start="30.03" data-end="35.309">it using `npm install puppeteer` you can `require('puppeteer')` in your Node.js script</span> <span data-start="35.309" data-end="41.64">and start automating. The first step to browser automation is… to launch an</span> <span data-start="41.64" data-end="48.449">actual browser and with Puppeteer, that’s just one line of code. Next, we open a new</span> <span data-start="48.449" data-end="54.54">page. This is equivalent to opening a new tab in your browser. Now let’s navigate</span> <span data-start="54.54" data-end="59.309">to a URL. This line of code ensures that the page has finished loading before</span> <span data-start="59.309" data-end="65.67">continuing with the rest of the script. Then we take a screenshot and save it to</span> <span data-start="65.67" data-end="71.76">a file before finally closing the browser. And that’s it — that’s the entire</span> <span data-start="71.76" data-end="76.229">script! We did all of that with just a few lines of code. And Puppeteer can do</span> <span data-start="76.229" data-end="81.479">much more: you can generate PDFs, evaluate JavaScript in pages, enter text in input</span> <span data-start="81.479" data-end="86.189">fields, click on elements… Almost anything you would manually do when using a</span> <span data-start="86.189" data-end="91.409">browser can be automated using Puppeteer. The Puppeteer project is fully open source</span> <span data-start="91.409" data-end="95.25">and has received contributions from individual contributors all around the</span> <span data-start="95.25" data-end="100.02">world as well as from companies like Mozilla, Sauce Labs, and Microsoft. At</span> </p>
<p><span data-start="100.02" data-end="104.219">Google, the Puppeteer team consists of Chrome engineers who also work on DevTools.</span> <span data-start="104.219" data-end="108.45">This might sound a little strange at first, but it actually makes</span> <span data-start="108.45" data-end="113.399">sense, because Puppeteer is built on top of the same underlying protocol that DevTools</span> <span data-start="113.399" data-end="117.99">also uses to communicate with the Chromium back-end. Because of this,</span> <span data-start="117.99" data-end="122.13">Puppeteer also gives you access to advanced browser functionality that is</span> <span data-start="122.13" data-end="127.259">usually only available through DevTools. For example, you might know that DevTools</span> <span data-start="127.259" data-end="131.93">lets you emulate print media so that you can easily debug print styles.</span> <span data-start="131.93" data-end="137.34">Well, Puppeteer lets you do the same thing in an automated script. Here we</span> <span data-start="137.34" data-end="142.68">call `page.emulateMediaType` to force print styles and then we save the result</span> <span data-start="142.68" data-end="148.92">as a PDF. Okay, now that you know what Puppeteer is, what it can do, and who is</span> <span data-start="148.92" data-end="155.069">working on it, let’s take a look at some recent feature additions. Similar to</span> <span data-start="155.069" data-end="159.93">emulating print styles, we recently added DevTools support for emulating light and</span> <span data-start="159.93" data-end="167.069">dark mode as well as other so-called “CSS media features”. We then shipped a new</span> </p>
<p><span data-start="167.069" data-end="171.9">Puppeteer API that lets you perform the same emulation programmatically. This</span> <span data-start="171.9" data-end="176.34">Puppeteer script takes two screenshots of your web app: one in light mode, and</span> <span data-start="176.34" data-end="183.569">one in dark mode. It works independently of your operating system settings. One of</span> <span data-start="183.569" data-end="188.79">my favorite features on web.dev/live is the schedule which adapts to your</span> <span data-start="188.79" data-end="193.439">local timezone. I live in Germany, so when I view the schedule I see something like</span> <span data-start="193.439" data-end="199.53">this. Today’s event started at 2:00 PM for me, but someone in Tokyo for example</span> <span data-start="199.53" data-end="204.719">would see a different time — for them the event started at 9:00 PM. I love that</span> <span data-start="204.719" data-end="208.769">the website just tells me what I need to know in my local time. Nobody likes doing</span> <span data-start="208.769" data-end="213.87">timezone math! To make it easier to test this kind of timezone-aware</span> <span data-start="213.87" data-end="218.569">functionality, we added DevTools support for emulating arbitrary time zones.</span> </p>
<p><span data-start="218.569" data-end="223.62">Yesterday’s event started on June 30th at 6 PM for me, but for someone in</span> <span data-start="223.62" data-end="231.389">Tokyo it was already 1 AM on July 1st. In addition to the new DevTools</span> <span data-start="231.389" data-end="236">functionality, we also added a new API to Puppeteer to let you change time zones</span> <span data-start="236" data-end="241.409">programmatically. This script emulates various time zones and then executes</span> <span data-start="241.409" data-end="246.269">some timezone-dependent JavaScript in the page context. We’re logging the same date</span> <span data-start="246.269" data-end="253.5">but in two different time zones, and that produces different output. Here’s another</span> <span data-start="253.5" data-end="258.87">example. This Puppeteer script forces the Tokyo time zone, then loads the web.dev LIVE</span> <span data-start="258.87" data-end="263.669">page, and finally takes a screenshot of just the schedule, similar to the</span> <span data-start="263.669" data-end="267.59">side-by-side screenshots we saw earlier.</span> <span data-start="268.34" data-end="273.06">DevTools recently gained support for simulating the effect of various vision</span> <span data-start="273.06" data-end="276.759">deficiencies, including blurred vision and color vision deficiencies.</span> <span data-start="276.759" data-end="281.83">This can help you identify accessibility issues related to color, such as bad</span> <span data-start="281.83" data-end="288.009">contrast. And guess what? We added a corresponding Puppeteer API that lets</span> <span data-start="288.009" data-end="292.18">you apply these simulations programmatically! This script takes a</span> <span data-start="292.18" data-end="295.749">screenshot of the web app after simulating blurred vision, achromatopsia</span> <span data-start="295.749" data-end="301.749">(or full color blindness), and deuteranopia which is red-green color blindness.</span> </p>
<p><span data-start="301.749" data-end="306.039">One feature we’re still experimenting with is the ability to register and use</span> <span data-start="306.039" data-end="310.839">custom selector query handlers. Many Puppeteer APIs deal with selector</span> <span data-start="310.839" data-end="315.61">strings, which by default use querySelector or querySelectorAll to find</span> <span data-start="315.61" data-end="319.149">elements in the page. We’ve heard from users that they want to be able to</span> <span data-start="319.149" data-end="323.319">provide their own selector query handlers with custom logic, and this new</span> <span data-start="323.319" data-end="328.21">feature now makes that possible. You can imagine providing a custom `hasText`</span> <span data-start="328.21" data-end="332.919">handler which looks for DOM nodes containing a string of text. Or maybe you</span> <span data-start="332.919" data-end="336.879">want to select elements across shadow DOM boundaries, which querySelector</span> <span data-start="336.879" data-end="343.81">doesn’t let you do. There’s one more feature I want to talk about, and it’s a</span> <span data-start="343.81" data-end="347.279">little different from all these API additions we’ve been covering until now.</span> </p>
<p><span data-start="347.279" data-end="352.779">Let’s go back to our very first example: launching a browser, navigating to a URL,</span> <span data-start="352.779" data-end="359.349">and taking a screenshot. Puppeteer was originally built for Chrome so when you</span> <span data-start="359.349" data-end="365.86">call `puppeteer.launch` it launches a Chromium browser by default. You can now</span> <span data-start="365.86" data-end="372.129">also specify this explicitly by using the `product` option. Okay, so we added a</span> <span data-start="372.129" data-end="376.689">new `product` option… by itself that’s probably not very interesting. But here</span> <span data-start="376.689" data-end="382.749">comes the exciting part! Instead of Chrome you can now specify Firefox and</span> <span data-start="382.749" data-end="388.809">then use the same Puppeteer API to test a real Firefox browser. By changing just</span> <span data-start="388.809" data-end="394.449">this one line we are now automating Firefox instead of Chrome. Firefox</span> <span data-start="394.449" data-end="399.039">support for Puppeteer is the result of an ongoing collaboration with Mozilla. Part</span> <span data-start="399.039" data-end="402.58">of this effort involves patching Puppeteer itself, but a big chunk of the</span> <span data-start="402.58" data-end="407.199">work happens in the Firefox codebase. The Puppeteer Firefox implementation is</span> <span data-start="407.199" data-end="410.59">still experimental and so not all the Puppeteer APIs</span> <span data-start="410.59" data-end="415.39">are yet compatible with Firefox, but Mozilla has been making great progress</span> <span data-start="415.39" data-end="421.15">here. In fact, as of mid-May, exactly 319 out of the 638</span> <span data-start="421.15" data-end="424.78">tests in Puppeteer’s test suite are passing on Firefox —</span> <span data-start="424.78" data-end="430.48">that’s exactly 50%! We’re hoping to ship Puppeteer with more</span> <span data-start="430.48" data-end="434.77">complete Firefox support soon. Longer-term we would love to support</span> </p>
<p><span data-start="434.77" data-end="438.97">Safari as well, and we’re actively working on making that happen in collaboration</span> <span data-start="438.97" data-end="442.9">with other browser vendors. We believe the right way to get to a fully</span> <span data-start="442.9" data-end="446.62">cross-browser Puppeteer is by standardizing a protocol that all</span> <span data-start="446.62" data-end="450.04">browsers can implement, instead of building on top of the proprietary</span> <span data-start="450.04" data-end="455.23">Chrome DevTools Protocol. In addition to all those new features, a lot of work has</span> <span data-start="455.23" data-end="459.64">been going on behind the scenes of Puppeteer. We recently finished migrating</span> <span data-start="459.64" data-end="463.39">the code base to TypeScript, we simplified our test runner, we</span> <span data-start="463.39" data-end="468.19">considerably improve the robustness of our continuous integration setup, and our</span> <span data-start="468.19" data-end="472.3">documentation keeps getting better and better. This work is often less user-</span> <span data-start="472.3" data-end="476.44">visible, but it’s crucially important because it enables us to iterate more</span> <span data-start="476.44" data-end="481.69">quickly and more confidently. I hope you enjoyed this overview of what’s new in</span> </p>
</section>