1
00:00:00,560 --> 00:00:03,410

[Music]

2
00:00:03,410 --> 00:00:06,140
[Applause]

3
00:00:06,140 --> 00:00:13,110
[Music]

4
00:00:13,120 --> 00:00:13,679
hello

5
00:00:13,679 --> 00:00:15,040
my name is shu and i work on the

6
00:00:15,040 --> 00:00:16,960
javascript specification as well as the

7
00:00:16,960 --> 00:00:18,080
v8 project

8
00:00:18,080 --> 00:00:19,680
my name is lescheck and i work as a

9
00:00:19,680 --> 00:00:22,480
performance engineer on the v8 vm

10
00:00:22,480 --> 00:00:24,400
so she what's new in javascript these

11
00:00:24,400 --> 00:00:25,519
days

12
00:00:25,519 --> 00:00:27,119
yeah a whole bunch of stuff has happened

13
00:00:27,119 --> 00:00:28,720
since last year and you might recognize

14
00:00:28,720 --> 00:00:29,920
some of the features we're going to talk

15
00:00:29,920 --> 00:00:32,399
about today from some of our colleagues

16
00:00:32,399 --> 00:00:34,800
2019 google i o talk because language

17
00:00:34,800 --> 00:00:36,640
features take a while to be standardized

18
00:00:36,640 --> 00:00:39,200
and to be shipped into browsers the ones

19
00:00:39,200 --> 00:00:40,480
we're going to be talking about today

20
00:00:40,480 --> 00:00:41,600
have shipped

21
00:00:41,600 --> 00:00:44,879
so let's start with the fun stuff like i

22
00:00:44,879 --> 00:00:46,000
said we're about to

23
00:00:46,000 --> 00:00:47,600
we're either shipped or about to ship

24
00:00:47,600 --> 00:00:49,120
quite a few syntax features that should

25
00:00:49,120 --> 00:00:51,199
make web devs lives easier

26
00:00:51,199 --> 00:00:54,239
for this talk we'll be focusing on two

27
00:00:54,239 --> 00:00:55,760
features that'll make dealing with

28
00:00:55,760 --> 00:00:56,559
optional

29
00:00:56,559 --> 00:00:58,480
values easier so leshik have you ever

30
00:00:58,480 --> 00:00:59,840
written code that dealt with

31
00:00:59,840 --> 00:01:00,719
configuration

32
00:01:00,719 --> 00:01:02,480
oh yeah definitely like always using a

33
00:01:02,480 --> 00:01:04,000
hash map for those things

34
00:01:04,000 --> 00:01:06,240
yeah so i'm keeping i'm writing this new

35
00:01:06,240 --> 00:01:07,760
chat app right something of a strength

36
00:01:07,760 --> 00:01:09,200
for google engineers

37
00:01:09,200 --> 00:01:10,960
i made some network parameters

38
00:01:10,960 --> 00:01:13,119
configurable which i keep in this map of

39
00:01:13,119 --> 00:01:14,240
configurations called

40
00:01:14,240 --> 00:01:16,640
config that you see on the screen but

41
00:01:16,640 --> 00:01:18,000
the network configuration

42
00:01:18,000 --> 00:01:19,840
is optional because it isn't always set

43
00:01:19,840 --> 00:01:21,360
by the user and it has

44
00:01:21,360 --> 00:01:23,119
sub configurations like the server and

45
00:01:23,119 --> 00:01:24,880
the port and maybe those aren't set by

46
00:01:24,880 --> 00:01:26,640
the user either handling that kind of

47
00:01:26,640 --> 00:01:28,240
optionality is kind of a pain

48
00:01:28,240 --> 00:01:30,560
currently folks do this with logical and

49
00:01:30,560 --> 00:01:31,600
like you see on the screen

50
00:01:31,600 --> 00:01:33,840
oh that's pretty good place yeah and for

51
00:01:33,840 --> 00:01:35,600
those chains of property accesses

52
00:01:35,600 --> 00:01:37,520
were at any point some property in the

53
00:01:37,520 --> 00:01:38,720
middle could turn out to be

54
00:01:38,720 --> 00:01:40,880
undefined we added this feature called

55
00:01:40,880 --> 00:01:42,399
optional chaining

56
00:01:42,399 --> 00:01:44,159
easier to show you on the screen than to

57
00:01:44,159 --> 00:01:46,079
talk you through it so

58
00:01:46,079 --> 00:01:48,079
the optional chaining feature is the

59
00:01:48,079 --> 00:01:49,920
question mark and the dot

60
00:01:49,920 --> 00:01:52,720
instead of a plain dot oh i see so if

61
00:01:52,720 --> 00:01:54,560
net config is undefined

62
00:01:54,560 --> 00:01:56,960
then netconfig.server is undefined until

63
00:01:56,960 --> 00:01:58,960
address isn't defined and so forth

64
00:01:58,960 --> 00:02:00,799
yeah almost it's a little bit more

65
00:02:00,799 --> 00:02:02,719
relaxed than that it's if it's undefined

66
00:02:02,719 --> 00:02:03,360
or null

67
00:02:03,360 --> 00:02:05,520
and specifically we call the set of

68
00:02:05,520 --> 00:02:06,880
things that are undefined or not

69
00:02:06,880 --> 00:02:07,439
knowledge

70
00:02:07,439 --> 00:02:09,679
so in the in this case if net config is

71
00:02:09,679 --> 00:02:11,200
knowledge the whole optional chain is

72
00:02:11,200 --> 00:02:12,000
undefined

73
00:02:12,000 --> 00:02:14,120
if net config isn't knowledge but net

74
00:02:14,120 --> 00:02:16,080
config.server is knowledge

75
00:02:16,080 --> 00:02:17,680
then again the whole thing is undefined

76
00:02:17,680 --> 00:02:19,360
you get the idea if nothing

77
00:02:19,360 --> 00:02:22,000
is knowledge then eventually you get the

78
00:02:22,000 --> 00:02:22,720
the

79
00:02:22,720 --> 00:02:25,040
whole property the most nested property

80
00:02:25,040 --> 00:02:25,840
access

81
00:02:25,840 --> 00:02:27,760
yeah cool that's a lot easier to read

82
00:02:27,760 --> 00:02:28,879
yeah i think so too

83
00:02:28,879 --> 00:02:30,959
now another common feature while dealing

84
00:02:30,959 --> 00:02:31,920
with configurations

85
00:02:31,920 --> 00:02:33,920
is default values and sometimes folks

86
00:02:33,920 --> 00:02:35,920
use logical or for this like you see on

87
00:02:35,920 --> 00:02:36,480
the screen

88
00:02:36,480 --> 00:02:37,599
oh yeah i've definitely written that

89
00:02:37,599 --> 00:02:39,760
before yeah and it usually works fine

90
00:02:39,760 --> 00:02:41,680
but sometimes it doesn't and is is

91
00:02:41,680 --> 00:02:43,680
really surprising when it doesn't

92
00:02:43,680 --> 00:02:45,760
suppose i add a configuration for

93
00:02:45,760 --> 00:02:47,200
enabling compression

94
00:02:47,200 --> 00:02:50,319
to the to the server do you spot the bug

95
00:02:50,319 --> 00:02:52,560
oh yeah right how would you actually

96
00:02:52,560 --> 00:02:54,480
explicitly disable compression right

97
00:02:54,480 --> 00:02:56,319
if it's false then false or true it's

98
00:02:56,319 --> 00:02:57,680
all going to be true

99
00:02:57,680 --> 00:02:59,840
yeah exactly if enable compression is

100
00:02:59,840 --> 00:03:00,800
false

101
00:03:00,800 --> 00:03:03,519
false or true like you said is true so

102
00:03:03,519 --> 00:03:05,200
what we really want to test here

103
00:03:05,200 --> 00:03:07,840
is not something is truthy which is what

104
00:03:07,840 --> 00:03:08,560
logical or

105
00:03:08,560 --> 00:03:10,879
tests for but actually if something is

106
00:03:10,879 --> 00:03:12,319
absent or present

107
00:03:12,319 --> 00:03:14,400
and we already are familiar with that

108
00:03:14,400 --> 00:03:16,720
concept that's knowledge

109
00:03:16,720 --> 00:03:18,800
so we introduced this new syntax feature

110
00:03:18,800 --> 00:03:20,319
called knowledge coalescing which is the

111
00:03:20,319 --> 00:03:21,599
two question marks

112
00:03:21,599 --> 00:03:23,519
and that does exactly what you want here

113
00:03:23,519 --> 00:03:25,440
for default values it tests for

114
00:03:25,440 --> 00:03:27,040
knowledgeness on the left-hand side

115
00:03:27,040 --> 00:03:28,959
if the left-hand side is knowledge then

116
00:03:28,959 --> 00:03:30,560
it evaluates to the right-hand side

117
00:03:30,560 --> 00:03:33,120
if the hand side is not knowledge then

118
00:03:33,120 --> 00:03:34,159
the whole thing is

119
00:03:34,159 --> 00:03:36,080
undefined so in this case enable

120
00:03:36,080 --> 00:03:37,920
compression is false question mark

121
00:03:37,920 --> 00:03:39,120
question mark true

122
00:03:39,120 --> 00:03:40,959
will still get you false because false

123
00:03:40,959 --> 00:03:42,799
is not null or undefined

124
00:03:42,799 --> 00:03:44,879
but if enable compression wasn't present

125
00:03:44,879 --> 00:03:46,000
if it's undefined

126
00:03:46,000 --> 00:03:48,319
then you get the default value of true

127
00:03:48,319 --> 00:03:50,159
that's pretty cool where can i use it

128
00:03:50,159 --> 00:03:51,920
so you can use both optional chaining

129
00:03:51,920 --> 00:03:53,200
and knowledge coalescing

130
00:03:53,200 --> 00:03:55,920
in chrome stable today now enough

131
00:03:55,920 --> 00:03:56,799
talking for me

132
00:03:56,799 --> 00:03:58,799
this that was just a taste of the new

133
00:03:58,799 --> 00:04:00,319
features you can find more on our

134
00:04:00,319 --> 00:04:02,000
website later we'll show you the link

135
00:04:02,000 --> 00:04:03,920
but you know we add all these new syntax

136
00:04:03,920 --> 00:04:05,680
features and i'm worried that supporting

137
00:04:05,680 --> 00:04:07,360
them all will slow down the parser

138
00:04:07,360 --> 00:04:10,080
v8 is known to be fast and i don't want

139
00:04:10,080 --> 00:04:10,480
to

140
00:04:10,480 --> 00:04:12,400
do anything to make it slower you know

141
00:04:12,400 --> 00:04:14,400
what that's a fair concern to have

142
00:04:14,400 --> 00:04:17,440
uh when we shipped es6 back in 2015

143
00:04:17,440 --> 00:04:19,040
we actually saw a big parsing

144
00:04:19,040 --> 00:04:20,320
performance drop like this is measured

145
00:04:20,320 --> 00:04:22,800
on octane on the code load benchmark

146
00:04:22,800 --> 00:04:25,280
and we had this big drop during this

147
00:04:25,280 --> 00:04:26,639
implementation phase

148
00:04:26,639 --> 00:04:29,840
but actually nowadays parsing speed

149
00:04:29,840 --> 00:04:31,600
doesn't matter as much as you might

150
00:04:31,600 --> 00:04:33,919
think oh really not anymore i thought

151
00:04:33,919 --> 00:04:35,600
parsing was pretty expensive but it's

152
00:04:35,600 --> 00:04:36,960
still not cheap

153
00:04:36,960 --> 00:04:38,320
but in the past year we've worked a lot

154
00:04:38,320 --> 00:04:39,759
to move a lot of parsing off of the main

155
00:04:39,759 --> 00:04:40,400
thread

156
00:04:40,400 --> 00:04:41,520
and be able to pass scripts while

157
00:04:41,520 --> 00:04:43,199
they're still loading so imagine that

158
00:04:43,199 --> 00:04:45,040
chrome sees a script like this

159
00:04:45,040 --> 00:04:47,520
the html parser gets up to it it sees

160
00:04:47,520 --> 00:04:48,080
the script

161
00:04:48,080 --> 00:04:50,080
and then has to pause the html parsing

162
00:04:50,080 --> 00:04:51,600
has to download to the script

163
00:04:51,600 --> 00:04:53,360
pause it execute it and only then can it

164
00:04:53,360 --> 00:04:55,360
continue pausing the html

165
00:04:55,360 --> 00:04:57,759
i know is strictly true because of

166
00:04:57,759 --> 00:04:59,600
optimizations like preloading

167
00:04:59,600 --> 00:05:01,600
no you're absolutely right uh this isn't

168
00:05:01,600 --> 00:05:02,800
actually the whole truth and

169
00:05:02,800 --> 00:05:04,240
the download of the script happens a lot

170
00:05:04,240 --> 00:05:06,400
earlier if there's a link preload or if

171
00:05:06,400 --> 00:05:08,479
the preposit finds the script earlier

172
00:05:08,479 --> 00:05:10,880
and if the download moves off of the

173
00:05:10,880 --> 00:05:12,160
main thread and earlier

174
00:05:12,160 --> 00:05:13,919
in time then pause and execute can move

175
00:05:13,919 --> 00:05:15,840
earlier too but the thing is the parsing

176
00:05:15,840 --> 00:05:16,639
itself

177
00:05:16,639 --> 00:05:18,479
can happen on a separate thread as well

178
00:05:18,479 --> 00:05:19,919
it's only really the execute that has

179
00:05:19,919 --> 00:05:21,199
happened on the main thread

180
00:05:21,199 --> 00:05:23,120
in particular if a script is marked as

181
00:05:23,120 --> 00:05:25,680
async you can keep processing the html

182
00:05:25,680 --> 00:05:27,840
up until uh the parsing of the async

183
00:05:27,840 --> 00:05:29,199
script is actually finished and

184
00:05:29,199 --> 00:05:31,039
it needs to execute and we've had

185
00:05:31,039 --> 00:05:33,280
support for this basically forever but

186
00:05:33,280 --> 00:05:35,360
it's been very limited

187
00:05:35,360 --> 00:05:37,360
we've only been able to concurrently

188
00:05:37,360 --> 00:05:38,479
pass one

189
00:05:38,479 --> 00:05:40,320
script at a time and we've only been

190
00:05:40,320 --> 00:05:41,919
able to do this very soon scripts

191
00:05:41,919 --> 00:05:43,759
yeah how come it's been so limited

192
00:05:43,759 --> 00:05:45,759
honestly just historical technical

193
00:05:45,759 --> 00:05:48,080
reasons which don't really hold anymore

194
00:05:48,080 --> 00:05:49,440
so one of the first things that we did

195
00:05:49,440 --> 00:05:51,600
was move everything from this dedicated

196
00:05:51,600 --> 00:05:52,000
thread

197
00:05:52,000 --> 00:05:54,400
into our global threat pool which meant

198
00:05:54,400 --> 00:05:55,600
that they could happen

199
00:05:55,600 --> 00:05:57,520
at the same time in parallel another

200
00:05:57,520 --> 00:05:58,960
thing that we changed was

201
00:05:58,960 --> 00:06:01,039
to have synchronous script also use this

202
00:06:01,039 --> 00:06:03,120
off-thread pausing functionality

203
00:06:03,120 --> 00:06:05,440
i'm kind of confused you said

204
00:06:05,440 --> 00:06:07,120
synchronous scripts but what's the point

205
00:06:07,120 --> 00:06:08,319
of parsing

206
00:06:08,319 --> 00:06:10,000
synchronous scripts in another thread

207
00:06:10,000 --> 00:06:11,919
isn't the whole point for non-async

208
00:06:11,919 --> 00:06:13,919
scripts that they block the main thread

209
00:06:13,919 --> 00:06:16,160
well that is the point for the execute

210
00:06:16,160 --> 00:06:17,600
but for the parsing

211
00:06:17,600 --> 00:06:19,520
even though we're pausing on a different

212
00:06:19,520 --> 00:06:21,280
thread if the main thread is free that

213
00:06:21,280 --> 00:06:22,479
means it can do other things

214
00:06:22,479 --> 00:06:24,800
it means that the user can scroll it

215
00:06:24,800 --> 00:06:26,800
means that the user can type it means

216
00:06:26,800 --> 00:06:28,479
that we can execute other javascript

217
00:06:28,479 --> 00:06:28,800
like

218
00:06:28,800 --> 00:06:31,759
on click handlers so it's actually very

219
00:06:31,759 --> 00:06:32,639
useful to be

220
00:06:32,639 --> 00:06:33,919
to have this empty space here on the

221
00:06:33,919 --> 00:06:35,759
main thread ah okay i see

222
00:06:35,759 --> 00:06:37,600
this is the difference between improving

223
00:06:37,600 --> 00:06:39,680
interactivity versus just improving the

224
00:06:39,680 --> 00:06:40,400
loading time

225
00:06:40,400 --> 00:06:42,479
right but we can improve loading as well

226
00:06:42,479 --> 00:06:43,919
uh because the parsing is happening on a

227
00:06:43,919 --> 00:06:45,520
separate thread uh we can actually move

228
00:06:45,520 --> 00:06:47,039
it earlier we can start pausing when the

229
00:06:47,039 --> 00:06:48,080
download starts

230
00:06:48,080 --> 00:06:49,599
and then as data comes in from the

231
00:06:49,599 --> 00:06:52,160
network we can feed it into the parser

232
00:06:52,160 --> 00:06:54,080
and then the actual pass time doesn't

233
00:06:54,080 --> 00:06:55,680
matter as much as you might think

234
00:06:55,680 --> 00:06:57,520
all that we need is for the parser to be

235
00:06:57,520 --> 00:06:58,960
faster than the network

236
00:06:58,960 --> 00:07:01,039
really the networks are already pretty

237
00:07:01,039 --> 00:07:03,039
fast not always but usually they are

238
00:07:03,039 --> 00:07:05,120
fair enough and you know caches are even

239
00:07:05,120 --> 00:07:06,400
faster so

240
00:07:06,400 --> 00:07:08,319
we can't completely ignore parser

241
00:07:08,319 --> 00:07:10,800
performance so we have invested a lot

242
00:07:10,800 --> 00:07:12,240
into improving the positive performance

243
00:07:12,240 --> 00:07:13,520
as well single threaded puzzle

244
00:07:13,520 --> 00:07:14,080
performance

245
00:07:14,080 --> 00:07:16,400
starting 2018 we put this big effort in

246
00:07:16,400 --> 00:07:18,080
put some of our best engineers on it

247
00:07:18,080 --> 00:07:20,400
and we've had actually very good results

248
00:07:20,400 --> 00:07:21,919
in improving past performance just

249
00:07:21,919 --> 00:07:22,400
through

250
00:07:22,400 --> 00:07:25,520
programming optimization yeah up and to

251
00:07:25,520 --> 00:07:27,039
the right that's the kind of graph i

252
00:07:27,039 --> 00:07:27,840
like to see

253
00:07:27,840 --> 00:07:29,520
really fascinating stuff the thing i

254
00:07:29,520 --> 00:07:31,440
learned quite a bit in just the past

255
00:07:31,440 --> 00:07:32,960
five minutes about making parsing

256
00:07:32,960 --> 00:07:34,319
compiling faster

257
00:07:34,319 --> 00:07:36,639
and web app performance in general and

258
00:07:36,639 --> 00:07:38,319
you got me thinking about this other big

259
00:07:38,319 --> 00:07:38,800
chunk

260
00:07:38,800 --> 00:07:41,919
of web app performance which is memory i

261
00:07:41,919 --> 00:07:43,280
was doing this thing the other day with

262
00:07:43,280 --> 00:07:44,879
with my chat app

263
00:07:44,879 --> 00:07:46,800
and you know i got it basically working

264
00:07:46,800 --> 00:07:47,919
and i was trying to measure

265
00:07:47,919 --> 00:07:49,520
the performance of the packets that i

266
00:07:49,520 --> 00:07:52,240
was getting from the server i wrote this

267
00:07:52,240 --> 00:07:54,080
little moving average class to compute

268
00:07:54,080 --> 00:07:55,599
the latency moving average

269
00:07:55,599 --> 00:07:57,919
of uh of the packets that i was getting

270
00:07:57,919 --> 00:07:58,879
from the websocket

271
00:07:58,879 --> 00:08:01,280
you see there that i add a message

272
00:08:01,280 --> 00:08:03,280
listener that basically all it does is

273
00:08:03,280 --> 00:08:05,520
it accumulates events into the event

274
00:08:05,520 --> 00:08:06,400
array

275
00:08:06,400 --> 00:08:09,039
and i use that later in this compute

276
00:08:09,039 --> 00:08:10,479
function which i don't show to actually

277
00:08:10,479 --> 00:08:12,240
compute the moving average

278
00:08:12,240 --> 00:08:13,840
and the way i use that is i have this

279
00:08:13,840 --> 00:08:15,440
component that

280
00:08:15,440 --> 00:08:18,240
when i start measuring and i want to see

281
00:08:18,240 --> 00:08:20,000
the live statistics of the

282
00:08:20,000 --> 00:08:21,840
moving average of the latency that i

283
00:08:21,840 --> 00:08:23,120
make a new instance of it

284
00:08:23,120 --> 00:08:24,960
and then when i stop i null it out

285
00:08:24,960 --> 00:08:26,160
because i don't want to keep all the

286
00:08:26,160 --> 00:08:28,000
events i accumulated in memory i know

287
00:08:28,000 --> 00:08:28,560
that

288
00:08:28,560 --> 00:08:31,440
v8 garbage collects memory that can no

289
00:08:31,440 --> 00:08:32,640
longer be reachable

290
00:08:32,640 --> 00:08:34,560
and as long as the moving average is

291
00:08:34,560 --> 00:08:35,919
reachable through the

292
00:08:35,919 --> 00:08:37,760
this.moving average property on the

293
00:08:37,760 --> 00:08:39,120
moving average component

294
00:08:39,120 --> 00:08:40,479
that the garbage collector cannot

295
00:08:40,479 --> 00:08:42,320
collect it which is why no doubt

296
00:08:42,320 --> 00:08:44,159
that makes a lot of sense to me yeah and

297
00:08:44,159 --> 00:08:45,440
i thought this would work fine

298
00:08:45,440 --> 00:08:46,959
but then what happened was you know it's

299
00:08:46,959 --> 00:08:49,120
a chat app i kept it open for a while

300
00:08:49,120 --> 00:08:49,600
and i

301
00:08:49,600 --> 00:08:51,839
opened the memory pane i see every once

302
00:08:51,839 --> 00:08:52,800
in a while that

303
00:08:52,800 --> 00:08:55,920
a gc happens and it moves you know it

304
00:08:55,920 --> 00:08:58,000
it collects some memory the memory goes

305
00:08:58,000 --> 00:08:59,120
down a little bit

306
00:08:59,120 --> 00:09:02,320
but it's pretty clear that the trend is

307
00:09:02,320 --> 00:09:03,600
up and to the right this is one of those

308
00:09:03,600 --> 00:09:04,880
graphs where up into the right is

309
00:09:04,880 --> 00:09:06,000
actually bad

310
00:09:06,000 --> 00:09:08,240
and what this was basically showing me

311
00:09:08,240 --> 00:09:09,839
is that it's a memory leak

312
00:09:09,839 --> 00:09:11,839
right that every g every time gc

313
00:09:11,839 --> 00:09:14,240
happened it wasn't able to collect all

314
00:09:14,240 --> 00:09:15,920
the memory so i just kept accumulating

315
00:09:15,920 --> 00:09:17,279
more and more memory and

316
00:09:17,279 --> 00:09:19,760
eventually if i kept this chat app open

317
00:09:19,760 --> 00:09:20,720
for

318
00:09:20,720 --> 00:09:23,279
another day or so my computer will have

319
00:09:23,279 --> 00:09:24,320
random memory

320
00:09:24,320 --> 00:09:26,880
memory leaks but v8 only collects

321
00:09:26,880 --> 00:09:28,399
objects that you can actually reach

322
00:09:28,399 --> 00:09:31,040
you node out your moving average uh

323
00:09:31,040 --> 00:09:32,080
field

324
00:09:32,080 --> 00:09:33,519
so the garbage collector should be able

325
00:09:33,519 --> 00:09:35,120
to reclaim its memory shouldn't that

326
00:09:35,120 --> 00:09:37,040
yeah so it's a common mistake but it's

327
00:09:37,040 --> 00:09:38,959
still pretty subtle i'm sure the

328
00:09:38,959 --> 00:09:40,959
more seasoned web developer would have

329
00:09:40,959 --> 00:09:42,160
spotted it right away

330
00:09:42,160 --> 00:09:44,640
so what's going on is that the websocket

331
00:09:44,640 --> 00:09:46,720
is holding on to all the event listeners

332
00:09:46,720 --> 00:09:49,600
strongly which means that until they are

333
00:09:49,600 --> 00:09:51,040
explicitly removed

334
00:09:51,040 --> 00:09:53,040
everything that is reachable via the

335
00:09:53,040 --> 00:09:54,800
event listener is also considered

336
00:09:54,800 --> 00:09:55,920
reachable and thus

337
00:09:55,920 --> 00:09:58,240
not collectible by the garbage collector

338
00:09:58,240 --> 00:10:00,279
so you see that use of

339
00:10:00,279 --> 00:10:02,560
this.events.push inside the event

340
00:10:02,560 --> 00:10:03,120
listener

341
00:10:03,120 --> 00:10:05,680
as long as that use is inside there the

342
00:10:05,680 --> 00:10:07,440
whole moving average instance

343
00:10:07,440 --> 00:10:09,440
is reachable from within the event

344
00:10:09,440 --> 00:10:10,720
listener and thus

345
00:10:10,720 --> 00:10:13,279
not garbage collectible so even when i

346
00:10:13,279 --> 00:10:14,160
nulled it out

347
00:10:14,160 --> 00:10:16,079
in the moving average component it was

348
00:10:16,079 --> 00:10:18,240
still considered alive by the garbage

349
00:10:18,240 --> 00:10:19,279
collector

350
00:10:19,279 --> 00:10:22,399
to deal with this folks often use what's

351
00:10:22,399 --> 00:10:24,480
called a disposable pattern where i have

352
00:10:24,480 --> 00:10:27,360
a a method that manually removes the

353
00:10:27,360 --> 00:10:29,839
event listener called dispose

354
00:10:29,839 --> 00:10:32,000
and that's kind of annoying and to use

355
00:10:32,000 --> 00:10:33,920
that the way i would do it is before i

356
00:10:33,920 --> 00:10:35,440
null it out in the moving average

357
00:10:35,440 --> 00:10:36,320
components

358
00:10:36,320 --> 00:10:38,160
i would have to remember to manually

359
00:10:38,160 --> 00:10:39,360
call dot bespoke

360
00:10:39,360 --> 00:10:41,040
what is this c plus plus you have to

361
00:10:41,040 --> 00:10:42,399
manually manage your memory although the

362
00:10:42,399 --> 00:10:43,519
whole point of calculation was that you

363
00:10:43,519 --> 00:10:44,560
don't have to bother with that sort of

364
00:10:44,560 --> 00:10:45,040
stuff

365
00:10:45,040 --> 00:10:47,200
yeah exactly and it's so easy to forget

366
00:10:47,200 --> 00:10:48,079
it too

367
00:10:48,079 --> 00:10:50,000
and this is all because the event

368
00:10:50,000 --> 00:10:51,760
listeners can't be garbage collected

369
00:10:51,760 --> 00:10:53,839
until you manually remove them so what

370
00:10:53,839 --> 00:10:55,920
if there was a way to actually tell the

371
00:10:55,920 --> 00:10:56,880
engine

372
00:10:56,880 --> 00:10:58,320
don't let me keep you from garbage

373
00:10:58,320 --> 00:11:00,079
collecting this thing even though

374
00:11:00,079 --> 00:11:01,920
it's reachable then you don't have to

375
00:11:01,920 --> 00:11:04,000
remember to manually call dispose

376
00:11:04,000 --> 00:11:06,560
or even need the disposable pattern and

377
00:11:06,560 --> 00:11:07,360
it turns out

378
00:11:07,360 --> 00:11:08,800
there's a new standard feature in

379
00:11:08,800 --> 00:11:11,120
javascript that lets you do exactly this

380
00:11:11,120 --> 00:11:13,360
weak rifts all right and before we go

381
00:11:13,360 --> 00:11:15,120
into that i have to give a quick

382
00:11:15,120 --> 00:11:16,800
disclaimer so we graphs are advanced

383
00:11:16,800 --> 00:11:17,920
feature that's hard to use correctly

384
00:11:17,920 --> 00:11:18,720
because garbage collection is

385
00:11:18,720 --> 00:11:19,760
unpredictable and very different from

386
00:11:19,760 --> 00:11:20,640
browser browser

387
00:11:20,640 --> 00:11:22,640
and even from even different from front

388
00:11:22,640 --> 00:11:23,839
to run of the same browser because of

389
00:11:23,839 --> 00:11:25,440
that unpredictability we didn't add weak

390
00:11:25,440 --> 00:11:26,800
drafts to the web for many years

391
00:11:26,800 --> 00:11:28,480
and you hopefully will never run into a

392
00:11:28,480 --> 00:11:30,000
memory leak or a bug that legibility

393
00:11:30,000 --> 00:11:31,040
needs it but on the rare

394
00:11:31,040 --> 00:11:32,399
occasion that you actually legitimately

395
00:11:32,399 --> 00:11:35,040
need a weak graph finally you can use it

396
00:11:35,040 --> 00:11:36,959
and fix your problem at the root all

397
00:11:36,959 --> 00:11:38,480
right back to

398
00:11:38,480 --> 00:11:41,519
the main programming so how am i using

399
00:11:41,519 --> 00:11:43,200
weak refs here to solve the previous

400
00:11:43,200 --> 00:11:43,600
problem

401
00:11:43,600 --> 00:11:46,320
i still have this event listener but now

402
00:11:46,320 --> 00:11:48,320
instead of directly registering that

403
00:11:48,320 --> 00:11:49,920
event listener function

404
00:11:49,920 --> 00:11:52,720
with the socket i wrap it in a weak ref

405
00:11:52,720 --> 00:11:53,839
it is the

406
00:11:53,839 --> 00:11:56,000
what's called the target of the we graph

407
00:11:56,000 --> 00:11:57,040
and inside

408
00:11:57,040 --> 00:11:59,760
the actual event listener i deref the

409
00:11:59,760 --> 00:12:00,399
weak ref

410
00:12:00,399 --> 00:12:03,040
and i call the function and this kind of

411
00:12:03,040 --> 00:12:05,040
indirection basically means that

412
00:12:05,040 --> 00:12:07,279
the function that is actually holding

413
00:12:07,279 --> 00:12:10,360
the moving average component alive via

414
00:12:10,360 --> 00:12:11,760
this.events.push

415
00:12:11,760 --> 00:12:14,160
is no longer kept from being garbage

416
00:12:14,160 --> 00:12:15,519
collected because

417
00:12:15,519 --> 00:12:18,160
it is a weakly held reference inside a

418
00:12:18,160 --> 00:12:19,040
weak ref

419
00:12:19,040 --> 00:12:22,000
okay what is weakcraft.traff return i

420
00:12:22,000 --> 00:12:22,720
see you're using

421
00:12:22,720 --> 00:12:25,040
optional chaining function called syntax

422
00:12:25,040 --> 00:12:26,560
here yeah good eye on that

423
00:12:26,560 --> 00:12:28,079
that that was not an example that we

424
00:12:28,079 --> 00:12:29,839
showed earlier but like

425
00:12:29,839 --> 00:12:31,360
optional chaining for property you can

426
00:12:31,360 --> 00:12:32,959
also optional chain a

427
00:12:32,959 --> 00:12:36,399
function call so if it's undefined then

428
00:12:36,399 --> 00:12:37,839
you don't end up making the call and the

429
00:12:37,839 --> 00:12:39,680
whole thing is undefined but that

430
00:12:39,680 --> 00:12:42,399
also suggests that draft here when the

431
00:12:42,399 --> 00:12:44,000
thing is actually collected

432
00:12:44,000 --> 00:12:46,480
will return undefined to recap here what

433
00:12:46,480 --> 00:12:48,160
it basically means is that

434
00:12:48,160 --> 00:12:50,800
you have to manually call draft because

435
00:12:50,800 --> 00:12:52,079
we're no longer

436
00:12:52,079 --> 00:12:54,240
preventing the garbage collector from

437
00:12:54,240 --> 00:12:55,519
from collecting

438
00:12:55,519 --> 00:12:58,240
the uh the event listener since it's

439
00:12:58,240 --> 00:12:59,680
wrapped up in a weak ref

440
00:12:59,680 --> 00:13:01,760
so every time you want to access it you

441
00:13:01,760 --> 00:13:03,279
have to manually drive

442
00:13:03,279 --> 00:13:05,279
and if the garbage collector has

443
00:13:05,279 --> 00:13:06,639
collected it then dref

444
00:13:06,639 --> 00:13:09,600
will return undefined okay so in this

445
00:13:09,600 --> 00:13:10,079
case

446
00:13:10,079 --> 00:13:11,920
the listener is reachable by this dot

447
00:13:11,920 --> 00:13:14,079
listener and once a particular moving

448
00:13:14,079 --> 00:13:15,920
average instance isn't reachable

449
00:13:15,920 --> 00:13:17,920
then the component and the component

450
00:13:17,920 --> 00:13:18,959
knows it out

451
00:13:18,959 --> 00:13:20,959
then the whole thing can be connected

452
00:13:20,959 --> 00:13:23,360
right exactly because we're no longer

453
00:13:23,360 --> 00:13:25,200
accidentally keeping moving average

454
00:13:25,200 --> 00:13:27,920
alive anymore via the event listener

455
00:13:27,920 --> 00:13:30,639
we can go back to what i naively thought

456
00:13:30,639 --> 00:13:32,240
would work in the first place when i no

457
00:13:32,240 --> 00:13:33,200
longer need

458
00:13:33,200 --> 00:13:34,959
all the data in the moving average

459
00:13:34,959 --> 00:13:36,639
instance i would just null it out and

460
00:13:36,639 --> 00:13:38,560
let the gc do its thing

461
00:13:38,560 --> 00:13:41,519
okay no way but hold on but now you've

462
00:13:41,519 --> 00:13:42,560
got this

463
00:13:42,560 --> 00:13:45,680
strongly held listener uh on the actual

464
00:13:45,680 --> 00:13:47,360
event listener that's calling the weak

465
00:13:47,360 --> 00:13:48,000
graph

466
00:13:48,000 --> 00:13:50,639
yeah that's a it's that's a good point

467
00:13:50,639 --> 00:13:51,760
you know i thought

468
00:13:51,760 --> 00:13:53,360
you wouldn't spot that but that's

469
00:13:53,360 --> 00:13:55,279
exactly right even though

470
00:13:55,279 --> 00:13:57,920
with this weak rift in direction i still

471
00:13:57,920 --> 00:13:59,760
have this event listener remember the

472
00:13:59,760 --> 00:14:01,839
socket still keeps strongly it just

473
00:14:01,839 --> 00:14:03,199
holds on to all the event listeners

474
00:14:03,199 --> 00:14:03,760
until i

475
00:14:03,760 --> 00:14:06,079
register it i still have this extra

476
00:14:06,079 --> 00:14:06,959
event listener

477
00:14:06,959 --> 00:14:08,720
so what do i do there there is a

478
00:14:08,720 --> 00:14:10,480
companion feature to wikraps called

479
00:14:10,480 --> 00:14:12,880
finalization registry that lets me do

480
00:14:12,880 --> 00:14:15,360
the thing that's needed which is i want

481
00:14:15,360 --> 00:14:17,199
the garbage collector to tell me

482
00:14:17,199 --> 00:14:19,519
when it has collected something so that

483
00:14:19,519 --> 00:14:21,040
i can perform some action

484
00:14:21,040 --> 00:14:22,880
at the point that an object has been

485
00:14:22,880 --> 00:14:25,040
collected or in gc parlance

486
00:14:25,040 --> 00:14:27,120
finalized that feature is called

487
00:14:27,120 --> 00:14:29,120
finalization registry

488
00:14:29,120 --> 00:14:31,680
on this slide what you see is that i

489
00:14:31,680 --> 00:14:33,920
make a finalization registry

490
00:14:33,920 --> 00:14:36,560
and when i add the new event listener i

491
00:14:36,560 --> 00:14:38,480
also register with the finalization

492
00:14:38,480 --> 00:14:39,760
registry meaning

493
00:14:39,760 --> 00:14:41,839
when the inner listener the thing that

494
00:14:41,839 --> 00:14:44,000
actually does the this.events.push is

495
00:14:44,000 --> 00:14:45,680
collected and remember it's collectible

496
00:14:45,680 --> 00:14:46,720
now because it's

497
00:14:46,720 --> 00:14:48,800
held in a weak ref when that's collected

498
00:14:48,800 --> 00:14:50,240
it's going to run this

499
00:14:50,240 --> 00:14:52,240
function that i passed the finalization

500
00:14:52,240 --> 00:14:54,240
registry asynchronously

501
00:14:54,240 --> 00:14:56,880
to remove the event listener cleaning up

502
00:14:56,880 --> 00:14:58,079
all the excess memory

503
00:14:58,079 --> 00:14:59,760
now again this is an advanced feature

504
00:14:59,760 --> 00:15:01,920
and hopefully you'll never need it

505
00:15:01,920 --> 00:15:03,920
so it doesn't actually pass the object

506
00:15:03,920 --> 00:15:06,320
itself into the finalizer there's a good

507
00:15:06,320 --> 00:15:06,880
uh

508
00:15:06,880 --> 00:15:08,720
observation there you see that the thing

509
00:15:08,720 --> 00:15:10,800
that actually gets past the finalizer

510
00:15:10,800 --> 00:15:13,519
are some other values the object that

511
00:15:13,519 --> 00:15:14,399
you want to

512
00:15:14,399 --> 00:15:15,760
observe the finalization of that's

513
00:15:15,760 --> 00:15:17,120
already been collected so you don't get

514
00:15:17,120 --> 00:15:18,000
that back

515
00:15:18,000 --> 00:15:19,440
in this case the thing we need to

516
00:15:19,440 --> 00:15:21,279
perform the finalization action to

517
00:15:21,279 --> 00:15:22,240
unregister

518
00:15:22,240 --> 00:15:24,079
are the socket and the wrapper listener

519
00:15:24,079 --> 00:15:25,440
and that's what we pass to the

520
00:15:25,440 --> 00:15:26,000
finalization

521
00:15:26,000 --> 00:15:28,160
registry all right that makes sense yeah

522
00:15:28,160 --> 00:15:29,600
and like i said this is a

523
00:15:29,600 --> 00:15:32,399
this is an advanced feature and this

524
00:15:32,399 --> 00:15:34,079
example here is pretty dense

525
00:15:34,079 --> 00:15:36,399
i recommend that you follow the link on

526
00:15:36,399 --> 00:15:37,759
the screen there to

527
00:15:37,759 --> 00:15:40,240
follow our full explainer on the v8.dev

528
00:15:40,240 --> 00:15:41,759
website for the feature

529
00:15:41,759 --> 00:15:44,320
so with all of that work i opened up the

530
00:15:44,320 --> 00:15:45,680
memory panel again i

531
00:15:45,680 --> 00:15:48,399
kept my chat app on for a while i start

532
00:15:48,399 --> 00:15:50,079
and stop measuring the latency

533
00:15:50,079 --> 00:15:53,279
and now i see that every time a gc does

534
00:15:53,279 --> 00:15:53,680
happen

535
00:15:53,680 --> 00:15:55,759
it's able to reclaim basically all the

536
00:15:55,759 --> 00:15:56,720
memory and then

537
00:15:56,720 --> 00:15:58,399
over a longer period of time i'm no

538
00:15:58,399 --> 00:16:00,160
longer accumulating memory

539
00:16:00,160 --> 00:16:02,720
and yeah it looks like i fixed the leak

540
00:16:02,720 --> 00:16:04,480
looks pretty tricky like i've

541
00:16:04,480 --> 00:16:06,480
collected garbage before and i don't do

542
00:16:06,480 --> 00:16:08,240
it particularly deterministically myself

543
00:16:08,240 --> 00:16:09,600
yes garbage collection is not

544
00:16:09,600 --> 00:16:11,199
predictable it's not it's

545
00:16:11,199 --> 00:16:12,880
non-deterministic don't depend on

546
00:16:12,880 --> 00:16:15,279
always running and that's why we we have

547
00:16:15,279 --> 00:16:16,399
kept saying that

548
00:16:16,399 --> 00:16:18,720
we crafts and finalization registry is

549
00:16:18,720 --> 00:16:20,240
an advanced feature

550
00:16:20,240 --> 00:16:23,120
so and that's a good point too um given

551
00:16:23,120 --> 00:16:24,639
the unpredictability of the garbage

552
00:16:24,639 --> 00:16:26,639
collector are there other things that

553
00:16:26,639 --> 00:16:29,519
the engine does to make apps slimmer

554
00:16:29,519 --> 00:16:31,120
actually yeah basically doing a lot of

555
00:16:31,120 --> 00:16:32,720
work to reduce its memory consumption

556
00:16:32,720 --> 00:16:34,160
there's actually been two major projects

557
00:16:34,160 --> 00:16:37,199
that landed last year which have focused

558
00:16:37,199 --> 00:16:39,199
on this points compression and v8 light

559
00:16:39,199 --> 00:16:40,240
and i can actually talk about both of

560
00:16:40,240 --> 00:16:42,079
them very quickly

561
00:16:42,079 --> 00:16:44,800
so point to compression first of all um

562
00:16:44,800 --> 00:16:45,440
you've probably

563
00:16:45,440 --> 00:16:49,360
heard that machines are 32-bit or 64-bit

564
00:16:49,360 --> 00:16:51,360
on 32-bit machines we have 32-bit

565
00:16:51,360 --> 00:16:53,120
pointers on 64-bit machines we have

566
00:16:53,120 --> 00:16:54,639
64-bit pointers

567
00:16:54,639 --> 00:16:57,600
and the whole point of this pun intended

568
00:16:57,600 --> 00:16:58,160
is that

569
00:16:58,160 --> 00:17:00,399
32-bit pointers can reference up to 4

570
00:17:00,399 --> 00:17:01,600
gigabytes of memory

571
00:17:01,600 --> 00:17:04,400
64-bit pointers can reference up to 18

572
00:17:04,400 --> 00:17:06,160
exabytes of memory which

573
00:17:06,160 --> 00:17:09,600
is quite a lot more and chrome wants to

574
00:17:09,600 --> 00:17:10,480
be able to run

575
00:17:10,480 --> 00:17:13,120
in 64-bit so that it can access more

576
00:17:13,120 --> 00:17:14,559
than four gigabytes of memory

577
00:17:14,559 --> 00:17:16,240
yeah chrome definitely needs more than

578
00:17:16,240 --> 00:17:18,400
four gigs yeah all right

579
00:17:18,400 --> 00:17:20,559
we've all heard we've all seen the same

580
00:17:20,559 --> 00:17:21,520
memes and

581
00:17:21,520 --> 00:17:22,959
you know fair enough if you've got a

582
00:17:22,959 --> 00:17:24,640
hundred times open with a thousand

583
00:17:24,640 --> 00:17:26,240
images and they're playing games and

584
00:17:26,240 --> 00:17:27,919
they're playing music

585
00:17:27,919 --> 00:17:31,200
it's going to use our memory but

586
00:17:31,200 --> 00:17:33,120
not necessarily each individual tab not

587
00:17:33,120 --> 00:17:34,640
necessarily each individual

588
00:17:34,640 --> 00:17:37,360
v8 instance and the key observation of

589
00:17:37,360 --> 00:17:39,200
point compression is that actually

590
00:17:39,200 --> 00:17:41,200
we can probably restrict each va

591
00:17:41,200 --> 00:17:42,240
instance to

592
00:17:42,240 --> 00:17:44,160
be less than four gig and if we can

593
00:17:44,160 --> 00:17:46,240
restrict it to be less than 4 gig

594
00:17:46,240 --> 00:17:48,160
that means we can pre-allocate a 4 gig

595
00:17:48,160 --> 00:17:50,559
area for it and force all objects to be

596
00:17:50,559 --> 00:17:52,240
allocated inside of that area

597
00:17:52,240 --> 00:17:54,000
and now instead of referencing those

598
00:17:54,000 --> 00:17:55,919
objects by a 64-bit pointer

599
00:17:55,919 --> 00:17:57,520
we can reference them by an offset like

600
00:17:57,520 --> 00:17:59,760
this under pointer compression

601
00:17:59,760 --> 00:18:01,360
you can take your 64-bit pointer and

602
00:18:01,360 --> 00:18:03,200
then you can split it in half

603
00:18:03,200 --> 00:18:05,120
you can split it into a base and an

604
00:18:05,120 --> 00:18:06,960
offset the base is the start of that

605
00:18:06,960 --> 00:18:08,480
four giga allocation area and the offset

606
00:18:08,480 --> 00:18:10,080
is the offset within it

607
00:18:10,080 --> 00:18:11,440
and then you only have to store the

608
00:18:11,440 --> 00:18:12,799
offset on objects which means that your

609
00:18:12,799 --> 00:18:13,600
pointers go

610
00:18:13,600 --> 00:18:15,520
half the size they go back to 32-bit

611
00:18:15,520 --> 00:18:16,960
size

612
00:18:16,960 --> 00:18:20,240
guessing it wasn't just easy as that it

613
00:18:20,240 --> 00:18:21,520
definitely wasn't

614
00:18:21,520 --> 00:18:23,120
it was a whole journey and there's a

615
00:18:23,120 --> 00:18:24,640
whole blog post describing that journey

616
00:18:24,640 --> 00:18:26,400
which was very exciting

617
00:18:26,400 --> 00:18:28,960
but as a little spoiler i can tell you

618
00:18:28,960 --> 00:18:30,880
that on typical websites

619
00:18:30,880 --> 00:18:33,679
we reduce memory by about forty percent

620
00:18:33,679 --> 00:18:35,120
yeah that's uh those are some very

621
00:18:35,120 --> 00:18:36,640
impressive numbers forty percent

622
00:18:36,640 --> 00:18:38,960
but what if a web app or an ogs program

623
00:18:38,960 --> 00:18:40,640
really wants to use more than

624
00:18:40,640 --> 00:18:42,559
the four gigs are you constricting apps

625
00:18:42,559 --> 00:18:44,720
to only have four gigs of memory

626
00:18:44,720 --> 00:18:48,400
well kind of but also not really

627
00:18:48,400 --> 00:18:49,919
first of all with points compression

628
00:18:49,919 --> 00:18:51,360
those objects are a lot smaller so you

629
00:18:51,360 --> 00:18:52,000
can fit

630
00:18:52,000 --> 00:18:53,600
a lot more of them into that four

631
00:18:53,600 --> 00:18:55,520
gigabyte allocation area and also

632
00:18:55,520 --> 00:18:57,840
this 4 gig only applies to a single v8

633
00:18:57,840 --> 00:18:58,960
instances

634
00:18:58,960 --> 00:19:01,679
javascript object heap so for example

635
00:19:01,679 --> 00:19:02,799
typed arrays

636
00:19:02,799 --> 00:19:04,640
they have their own external memory

637
00:19:04,640 --> 00:19:06,240
backing so they're not included

638
00:19:06,240 --> 00:19:08,320
wasm instances have their own 4 gigabyte

639
00:19:08,320 --> 00:19:10,559
allocation area so those are separate

640
00:19:10,559 --> 00:19:12,640
even other va instances inside of web

641
00:19:12,640 --> 00:19:13,840
workers

642
00:19:13,840 --> 00:19:16,320
and on other tabs have their own 4gb

643
00:19:16,320 --> 00:19:17,280
location area

644
00:19:17,280 --> 00:19:20,240
so only restricting one v8 instance not

645
00:19:20,240 --> 00:19:20,960
all of them

646
00:19:20,960 --> 00:19:23,280
the other big project last year was v8

647
00:19:23,280 --> 00:19:24,320
light

648
00:19:24,320 --> 00:19:25,679
and this was this was a really

649
00:19:25,679 --> 00:19:26,880
interesting one because we thought to

650
00:19:26,880 --> 00:19:27,440
ourselves

651
00:19:27,440 --> 00:19:29,760
what would happen if we just gave up on

652
00:19:29,760 --> 00:19:30,720
performance

653
00:19:30,720 --> 00:19:32,640
and tried to just improve memory how far

654
00:19:32,640 --> 00:19:33,919
could we actually get

655
00:19:33,919 --> 00:19:36,160
for memory constrained devices where v8

656
00:19:36,160 --> 00:19:37,600
just couldn't run at all without the

657
00:19:37,600 --> 00:19:38,720
memory that it needed

658
00:19:38,720 --> 00:19:39,840
yeah that's an interesting thought

659
00:19:39,840 --> 00:19:41,600
experiment i guess if you run slowly

660
00:19:41,600 --> 00:19:43,120
that's better than not being to run at

661
00:19:43,120 --> 00:19:44,640
all because you're out of memory right

662
00:19:44,640 --> 00:19:45,600
absolutely

663
00:19:45,600 --> 00:19:47,200
the approach that we took was to just

664
00:19:47,200 --> 00:19:49,440
look at typical websites and

665
00:19:49,440 --> 00:19:51,120
look at what kind of things arctic

666
00:19:51,120 --> 00:19:52,799
actually taking up memory there

667
00:19:52,799 --> 00:19:56,000
48 was user data there's not

668
00:19:56,000 --> 00:19:58,160
really much we can do about that uh

669
00:19:58,160 --> 00:19:59,440
projects like point compression are

670
00:19:59,440 --> 00:20:01,200
going to reduce that by a lot

671
00:20:01,200 --> 00:20:03,120
but we can't really have any targeted

672
00:20:03,120 --> 00:20:04,640
optimizations that reduce the amount of

673
00:20:04,640 --> 00:20:05,520
data that users

674
00:20:05,520 --> 00:20:07,360
create and there's this big bucket of

675
00:20:07,360 --> 00:20:08,400
other because there's always a big

676
00:20:08,400 --> 00:20:09,520
bucket called other and we couldn't

677
00:20:09,520 --> 00:20:10,880
reduce that either with targeted

678
00:20:10,880 --> 00:20:11,840
optimizations

679
00:20:11,840 --> 00:20:14,640
but we did look at some of the top users

680
00:20:14,640 --> 00:20:16,400
of memory and we decided to

681
00:20:16,400 --> 00:20:18,880
try and target those right so right off

682
00:20:18,880 --> 00:20:20,000
the bat if you're not worried about

683
00:20:20,000 --> 00:20:21,120
performance at all you don't need to

684
00:20:21,120 --> 00:20:22,080
optimize code

685
00:20:22,080 --> 00:20:24,559
that makes sense to me absolutely um and

686
00:20:24,559 --> 00:20:25,679
if you don't need to optimize code you

687
00:20:25,679 --> 00:20:26,880
don't need to really collect type

688
00:20:26,880 --> 00:20:28,400
feedback either because that's just

689
00:20:28,400 --> 00:20:29,919
storing the data that we need for

690
00:20:29,919 --> 00:20:31,760
optimization and it's only used for

691
00:20:31,760 --> 00:20:33,280
performance

692
00:20:33,280 --> 00:20:35,520
even the bike agent that we generate you

693
00:20:35,520 --> 00:20:37,039
don't have to store that you can just

694
00:20:37,039 --> 00:20:38,640
compile it on the fly whenever you need

695
00:20:38,640 --> 00:20:40,400
it and get rid of it afterwards sounds a

696
00:20:40,400 --> 00:20:40,880
little

697
00:20:40,880 --> 00:20:42,720
different to me though by code is

698
00:20:42,720 --> 00:20:44,720
unoptimized code and if you're even

699
00:20:44,720 --> 00:20:46,240
getting rid of that that sounds like

700
00:20:46,240 --> 00:20:47,760
you're giving up more than just a little

701
00:20:47,760 --> 00:20:48,960
bit of performance

702
00:20:48,960 --> 00:20:50,960
yeah the first prototypes of v8 light

703
00:20:50,960 --> 00:20:53,280
were pretty slow

704
00:20:53,280 --> 00:20:54,960
but then we realized that we could get a

705
00:20:54,960 --> 00:20:56,559
lot of these gains without actually

706
00:20:56,559 --> 00:20:58,320
sacrificing performance at all just by

707
00:20:58,320 --> 00:20:59,919
being a little bit lazier

708
00:20:59,919 --> 00:21:01,679
yeah i'm something of an expert being

709
00:21:01,679 --> 00:21:03,600
lazy myself yeah i'm pretty good at

710
00:21:03,600 --> 00:21:05,039
being lazy myself too

711
00:21:05,039 --> 00:21:07,840
but as an expert in laziness you know

712
00:21:07,840 --> 00:21:08,720
right

713
00:21:08,720 --> 00:21:10,880
that being lazy doesn't just mean not

714
00:21:10,880 --> 00:21:12,080
doing anything at all

715
00:21:12,080 --> 00:21:13,840
it means not doing anything until you

716
00:21:13,840 --> 00:21:15,520
you're really required to

717
00:21:15,520 --> 00:21:18,240
so we took the same approach with va

718
00:21:18,240 --> 00:21:19,440
let's talk about those

719
00:21:19,440 --> 00:21:20,480
feedback factors that i mentioned

720
00:21:20,480 --> 00:21:22,640
previously the type feedback

721
00:21:22,640 --> 00:21:24,000
you're not going to make get much

722
00:21:24,000 --> 00:21:25,520
benefit from type feedback if you only

723
00:21:25,520 --> 00:21:26,720
run a function once or twice

724
00:21:26,720 --> 00:21:28,159
it's only where you can start benefiting

725
00:21:28,159 --> 00:21:29,679
you after you run it tens or hundreds of

726
00:21:29,679 --> 00:21:31,039
times

727
00:21:31,039 --> 00:21:33,760
so we can delay creating this type

728
00:21:33,760 --> 00:21:34,880
feedback until

729
00:21:34,880 --> 00:21:36,080
we've already had a couple of runs of

730
00:21:36,080 --> 00:21:38,159
this function taking off some of those

731
00:21:38,159 --> 00:21:39,039
feedback vectors

732
00:21:39,039 --> 00:21:40,640
but not all of them same thing with

733
00:21:40,640 --> 00:21:42,320
source positions we only need those

734
00:21:42,320 --> 00:21:44,320
for printing line numbers when we print

735
00:21:44,320 --> 00:21:46,720
exception stack traces or for printing

736
00:21:46,720 --> 00:21:49,120
uh stack traces in devtools so if we can

737
00:21:49,120 --> 00:21:50,799
delay calculating those two later then

738
00:21:50,799 --> 00:21:52,559
we save a lot of space as well

739
00:21:52,559 --> 00:21:54,880
even by code we have this capability of

740
00:21:54,880 --> 00:21:56,159
getting rid of a bicode that we don't

741
00:21:56,159 --> 00:21:56,559
need

742
00:21:56,559 --> 00:21:58,880
so we can just get rid of old bytecode

743
00:21:58,880 --> 00:22:00,159
keep around by code that we're still

744
00:22:00,159 --> 00:22:00,559
using

745
00:22:00,559 --> 00:22:02,240
and save a little bit of memory there

746
00:22:02,240 --> 00:22:04,320
and there were a bunch of tiny projects

747
00:22:04,320 --> 00:22:06,480
targeting these top memory users which

748
00:22:06,480 --> 00:22:07,760
are described in this blog post in a lot

749
00:22:07,760 --> 00:22:08,799
more detail

750
00:22:08,799 --> 00:22:10,880
but again spoiler alert they reduce

751
00:22:10,880 --> 00:22:12,080
memory by 10

752
00:22:12,080 --> 00:22:15,039
to 30 on typical websites nice so

753
00:22:15,039 --> 00:22:16,240
there's actually been a lot more going

754
00:22:16,240 --> 00:22:17,039
on in v8

755
00:22:17,039 --> 00:22:19,039
in the last year we only had time to

756
00:22:19,039 --> 00:22:20,400
talk about a couple of projects

757
00:22:20,400 --> 00:22:22,159
i recommend you visit our blog where we

758
00:22:22,159 --> 00:22:24,880
post about new versions of v8 we talk

759
00:22:24,880 --> 00:22:25,440
about

760
00:22:25,440 --> 00:22:28,000
exciting new things that we just like to

761
00:22:28,000 --> 00:22:28,880
talk about

762
00:22:28,880 --> 00:22:30,559
it's a great read and we look forward to

763
00:22:30,559 --> 00:22:32,320
seeing you there thank you very much for

764
00:22:32,320 --> 00:22:33,919
all the viewers who joined us for this

765
00:22:33,919 --> 00:22:36,000
whirlwind tour of

766
00:22:36,000 --> 00:22:37,919
the java what's new in the javascript

767
00:22:37,919 --> 00:22:40,240
language and the new developments in the

768
00:22:40,240 --> 00:22:41,600
engine itself that makes learning

769
00:22:41,600 --> 00:22:43,840
javascript both faster and to use less

770
00:22:43,840 --> 00:22:44,480
memory

771
00:22:44,480 --> 00:22:45,840
we definitely didn't have time to go

772
00:22:45,840 --> 00:22:47,120
into all the new features that were

773
00:22:47,120 --> 00:22:48,960
added to javascript so please give our

774
00:22:48,960 --> 00:22:49,760
blog

775
00:22:49,760 --> 00:22:52,840
a read thank you very much thanks

776
00:22:52,840 --> 00:22:59,390
everyone

777
00:22:59,400 --> 00:23:01,590
[Applause]

778
00:23:01,590 --> 00:23:08,870
[Music]

